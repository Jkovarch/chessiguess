<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Shadow Chess Survival</title>
    
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
            font-size: 16px;

            
        }

        :root{

            color-scheme: dark;
        }

        #gameStart {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            font-size: 16px;
            text-align: center;
            max-width: 80%;
            z-index: 1000;
            overflow: scroll;
            min-height: 100px;
            
        }

        #gameStart h2 {
            font-size: 24px;
            margin-bottom: 10px;
        }

        #gameStart p {
            margin: 10px 0;
        }

        #startGameButton {
            margin-top: 20px;
            padding: 10px 20px;
            font-size: 18px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        #startGameButton:hover {
            background-color: #45a049;
        }

        #gameContainer {
            display: flex;
            flex-direction: column;
            max-width: 100%;
            padding: 10px;
        }

        #header, #footer {
            width: 100%;

        }

        #canvasContainer {
            width: 100%;
            display: flex;
            max-width: 600px;
            align-items: center;
            margin: 0 auto;
        }

        #gameCanvas {
            display: block; /* Removes any extra space below the canvas */
            max-width: 100%;
            max-height: 100%;
        }

        #controls, #pieceButtons, #potionRecipes {
            display: flex;
            justify-content: space-around;
            margin-top: 10px;
        }

        button, .pieceButton, #potionButton {
            padding: 10px;
            font-size: 16px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        .pieceButton, #potionButton {
            padding: 5px 10px;
            font-size: 14px;
        }

        .pieceButton:disabled, #peekButton:disabled, .potionButton:disabled {
            background-color: #cccccc;
            color: #666666;
            cursor: not-allowed;
        }

        #changeToK {
            background-color: #3F51B5;
        }

        #peekButton {
            background-color: #9C27B0;
        }

        #potionRecipes div {
            background-color: #6e0a96;
            padding: 5px;
            border-radius: 5px;
            font-size: 14px;
        }

        .potionButton-available, .potionButton:enabled {
            background-color: #4CAF50;
            color: white;
        }

        .potionButton:enabled:hover {
            background-color: #6e0a96;
        }

        .popup-container {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
        }

        .popup {
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            margin-bottom: 5px;
            animation: fadeOut 2s forwards;
        }

        @keyframes fadeOut {
            0% { opacity: 1; }
            70% { opacity: 1; }
            100% { opacity: 0; }
        }

        .game-over {
            position: fixed;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 20px;
            border-radius: 10px;
            font-size: 16px;
            text-align: center;
            max-width: 80%;
            z-index: 1000;
        }

        .game-over h2 {
            font-size: 24px;
            margin-bottom: 10px;
        }

        .game-over p {
            margin: 5px 0;
        }

        .game-over-subheading {
            font-style: italic;
            margin-bottom: 15px;
            color: #ffa500;
        }

        .game-over button {
            margin: 5px;
        }

        .game-over button:hover {
            background-color: #45a049;
        }

        .highlight {
            position: absolute;
            width: 12.5%; /* 100% / 8 for an 8x8 chess board */
            height: 12.5%;
            background-color: rgba(255, 255, 0, 0.5); /* Yellow with 50% opacity */
            pointer-events: none; /* Allows clicks to pass through */
        }

        .attack-highlight {
            position: absolute;
            width: 12.5%;
            height: 12.5%;
            background-color: rgba(255, 0, 0, 0.5); /* Red with 50% opacity */
            pointer-events: none;
        }

        .popup-text {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            font-weight: bold;
            text-align: center;
            pointer-events: none;
            animation: fadeInOut 3s ease-in-out forwards;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            z-index: 1000;
        }

        @keyframes fadeInOut {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
            10% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            90% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(1.2); }
        }

        .popup-text-green { color: #00ff00; }
        .popup-text-gold { color: #ffd700; }
        .popup-text-blue { color: #00ff00; }

        @media (max-width: 600px) {
            body {
                font-size: 14px;
            }

            #gameStart{
                overflow: scroll;
                min-height: 100px;
            }

            #footer {
                flex-direction: column;
            }
            
            #controls, #potionRecipes, #potionButtons {
                width: 100%;
                margin-bottom: 10px;
            }

            #header h1 {
                font-size: 1.2rem;
            }

            button, .pieceButton, #potionButton {
                padding: 12px;
                font-size: 16px;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="header">
            <!--<center><H1> Alchemist Chess</H1></center>-->
            
        </div>
        <div id="canvasContainer">
            <canvas id="gameCanvas"></canvas>
        </div>
        <div id="footer">
            <div id="controls">
                <button id="undoButton">Undo</button>
                <button id="changeToK" class="pieceButton" data-piece="K" data-cost="0">King (0)</button>
                <button id="toggleDotsButton">Hint (10)</button>
                <button id="peekButton">Peek (5)</button>
            </div>
            <div id="potionButtons">
                <button id="useKnightPotion" class="potionButton" disabled>Knight Potion: 0 of 2</button>
                <button id="useRookPotion" class="potionButton" disabled>Rook Potion: 0 of 3</button>
                <button id="useBishopPotion" class="potionButton" disabled>Bishop Potion: 0 of 3</button>
                <button id="useQueenPotion" class="potionButton" disabled>Queen Potion: 0 of 5</button>
            </div>
            <div>
            <center><div id="scoreText">Score: 0</div>
            <div id="pieceText">Current Piece: King</div>
            <div id="turnText">Turns: 0</div>
            <div id="ingredientText">Ingredients Collected: 0</div> <!-- New line for ingredient counter -->
            </center>
            </div>
            <!-- <div id="pieceButtons">
                
                <button id="changeToN" class="pieceButton" data-piece="N" data-cost="15">Knight (15)</button>
                <button id="changeToR" class="pieceButton" data-piece="R" data-cost="17">Rook (17)</button>
                <button id="changeToB" class="pieceButton" data-piece="B" data-cost="18">Bishop (18)</button>
                <button id="changeToQ" class="pieceButton" data-piece="Q" data-cost="25">Queen (25)</button>
            </div> -->
        </div>
    </div>

    <script defer>
        let canvas, ctx;
        let GAME_SIZE = 800;
        const ROWS = 8;
        const COLS = 8;
        let SQUARE_SIZE = GAME_SIZE / COLS;

        const IMAGES = {};
        const gameState = {
            chessBoard: null,
            finalState: null,
            isShowingFinalState: true,
            isGameLoopRunning: true,
            mousePos: null
        };

        class Piece {
            constructor(color, pieceType) {
                this.color = color;
                this.pieceType = pieceType;
                this.image = IMAGES[`${color}${pieceType}`];
                this.isAnimating = false;
                this.direction = color === 'w' ? -1 : 1;
                this.hasMoved = false;
            }

            draw(ctx, row, col) {
                const x = col * SQUARE_SIZE;
                const y = row * SQUARE_SIZE;
                ctx.drawImage(this.image, x, y, SQUARE_SIZE, SQUARE_SIZE);
            }

            getPossibleMoves(row, col, board) {
                switch(this.pieceType) {
                    case 'p': return this.getPawnMoves(row, col, board);
                    case 'K': return this.getKingMoves(row, col);
                    case 'Q': return this.getQueenMoves(row, col);
                    case 'R': return this.getRookMoves(row, col);
                    case 'B': return this.getBishopMoves(row, col);
                    case 'N': return this.getKnightMoves(row, col);
                    default: return [];
                }
            }

            findPawnToMove() {
                let closestToKing = null;
                let closestToPromotion = null;
                let minDistanceToKing = Infinity;
                let minDistanceToPromotion = Infinity;

                for (const [row, col] of this.enemies) {
                    const piece = this.board[row][col];
                    if (piece && piece.pieceType === 'p') {
                        // Check distance to king
                        const distanceToKing = Math.max(Math.abs(row - this.selectedPos[0]), Math.abs(col - this.selectedPos[1]));
                        if (distanceToKing < minDistanceToKing) {
                            minDistanceToKing = distanceToKing;
                            closestToKing = [row, col];
                        }

                        // Check distance to promotion
                        const distanceToPromotion = piece.direction === 1 ? (ROWS - 1 - row) : row;
                        if (distanceToPromotion < minDistanceToPromotion) {
                            minDistanceToPromotion = distanceToPromotion;
                            closestToPromotion = [row, col];
                        }
                    }
                }

                // Randomly choose between the two pawns
                return Math.random() < 0.5 ? closestToKing : closestToPromotion;
            }

            getPawnMoves(row, col, board) {
                const moves = [];
                const forward = row + this.direction;
                
                // Single square move
                if (forward >= 0 && forward < ROWS && board[forward][col] === null) {
                    moves.push([forward, col]);
                    
                    // Two-square move on first move
                    if (!this.hasMoved) {
                        const twoForward = forward + this.direction;
                        if (twoForward >= 0 && twoForward < ROWS && board[twoForward][col] === null) {
                            moves.push([twoForward, col]);
                        }
                    }
                }
                
                // Capture diagonally
                for (const dc of [-1, 1]) {
                    const newCol = col + dc;
                    if (newCol >= 0 && newCol < COLS && forward >= 0 && forward < ROWS) {
                        const target = board[forward][newCol];
                        if (target && target.color !== this.color) {
                            moves.push([forward, newCol]);
                        }
                    }
                }
                
                return moves;
            }

            getKingMoves(row, col) {
                return [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]]
                    .map(([r, c]) => [row + r, col + c]);
            }

            getQueenMoves(row, col) {
                return [...this.getRookMoves(row, col), ...this.getBishopMoves(row, col)];
            }

            getRookMoves(row, col) {
                let moves = [];
                for (let i = 0; i < ROWS; i++) if (i !== row) moves.push([i, col]);
                for (let j = 0; j < COLS; j++) if (j !== col) moves.push([row, j]);
                return moves;
            }

            getBishopMoves(row, col) {
                let moves = [];
                for (let i = 1; i < ROWS; i++) {
                    if (row + i < ROWS && col + i < COLS) moves.push([row + i, col + i]);
                    if (row + i < ROWS && col - i >= 0) moves.push([row + i, col - i]);
                    if (row - i >= 0 && col + i < COLS) moves.push([row - i, col + i]);
                    if (row - i >= 0 && col - i >= 0) moves.push([row - i, col - i]);
                }
                return moves;
            }

            getKnightMoves(row, col) {
                return [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]]
                    .map(([r, c]) => [row + r, col + c]);
            }

        }

        class Ingredient {
            constructor(name, type, rarity = 'common', row, col) {
                this.name = name;
                this.type = type;
                this.rarity = rarity;
                this.row = row;
                this.col = col;
                this.lifespan = 13; // 5 green + 5 orange + 3 red
            }

            getColor() {
                if (this.lifespan > 8) return 'green';
                if (this.lifespan > 3) return 'orange';
                return 'red';
            }

            decreaseLifespan() {
                this.lifespan--;
                return this.lifespan <= 0;
            }
        }

        class PotionRecipe {
            constructor(name, ingredients, requiredCount) {
                this.name = name;
                this.ingredients = ingredients;
                this.requiredCount = requiredCount;
                
            }

            isUnlocked(collectedIngredients) {
                const uniqueIngredients = new Set(collectedIngredients
                    .filter(ing => this.ingredients.includes(ing.name))
                    .map(ing => ing.name));
                return uniqueIngredients.size >= this.requiredCount;
            }
        }

        class Board {
            constructor() {
                this.board = Array(ROWS).fill().map(() => Array(COLS).fill(null));
                this.playerPiece = new Piece('w', 'K');
                this.board[3][3] = this.playerPiece;
                this.enemies = [];
                this.turnCount = 0;
                this.score = 0;
                this.selectedPos = [3, 3];
                this.attackingForce = [];
                this.mainAttacker = null;
                this.lastSpawned = null;
                this.lastMovedEnemyFrom = null;
                this.lastMovedEnemyTo = null;
                this.lastPlayerPosition = null;
                this.emergencyMove = false;
                this.showDots = false;
                this.lastPieceChange = null;
                this.pendingPieceChange = null;
                this.pieceChangeCost = {'K': 0, 'N': 15, 'B': 18, 'R': 17, 'Q': 25};
                this.previousState = null;
                this.canUndo = false;
                this.lastPieceCost = 0;
                this.lastMoveScoreGain = 0;
                this.popUpTexts = [];
                this.popUpQueue = [];
                this.isShowingPopUp = false;
                this.turnPopUps = [];
                this.lastUpdateTime = Date.now();
                // this.updatePieceButtons();
                this.blackPiecesVisible = false;
                this.peekActivated = false;
                this.peekCost = 10;
                this.updatePeekButton();
                this.ingredients = [];
                this.lastIngredientSpawn = -5;
                this.ingredientsCollected = 0;
                this.collectedIngredients = [];
                this.unlockedPotions = new Set();
                this.justUsedPotion = false;
                this.lastPrintedTurn = -1;
                this.potionsUsed = 0;
                this.emergencyTurnsUsed = 0;
                this.piecesCaptured = 0;
                this.hoverPos = null;
                this.animationQueue = [];
                this.isAnimating = false;
                this.animations = [];
                this.pendingMoves = [];
                this.isGameOver = false;
                this.capturingPiece = null;
                this.capturingPosition = null;
                this.revealAllPieces = false;
                this.pieceLimits = {
                    early: { Q: 2, R: 3, B: 3, N: 4 },
                    late: { Q: 3, R: 4, B: 4, N: 5 }
                };

                this.spawnMode = "white border only";
                this.difficultyLevel = 0;
                this.spawnRates = {
                    'p': 0.50,
                    'N': 0.35,
                    'B': 0.20,
                    'R': 0.20,
                    'Q': 0.05
                };


                this.recipes = [
                    new PotionRecipe('Rook Potion', ['Rookie Dough', 'Brookcoli', 'Castlerole', 'Castle oil'], 3),
                    new PotionRecipe('Bishop Potion', ['Bish-hops', 'Bisqueop', 'Bishchops', 'Priestry', 'Priestrami', 'Pastor'], 3),
                    new PotionRecipe('Knight Potion', ['KNIGHTmeg', 'HORSEraddish', 'KNIGHTella', 'VegiKNIGHT'], 2),
                    new PotionRecipe('Queen Potion', ['QUEENwa', 'Ice QUEEN', 'QUEENce', 'QUEEN cuisine', 'Sour queen'], 5)
                ];
                this.allIngredients = [
                    new Ingredient('Rookie Dough', 'rook', 'common'),
                    new Ingredient('Brookcoli', 'rook', 'common'),
                    new Ingredient('Castlerole', 'rook', 'uncommon'),
                    new Ingredient('Castle oil', 'rook', 'rare'),
                    new Ingredient('Bish-hops', 'bishop', 'common'),
                    new Ingredient('Bisqueop', 'bishop', 'common'),
                    new Ingredient('Bishchops', 'bishop', 'uncommon'),
                    new Ingredient('Priestry', 'bishop', 'uncommon'),
                    new Ingredient('Priestrami', 'bishop', 'rare'),
                    new Ingredient('KNIGHTmeg', 'knight', 'common'),
                    new Ingredient('HORSEraddish', 'knight', 'common'),
                    new Ingredient('KNIGHTella', 'knight', 'uncommon'),
                    new Ingredient('VegiKNIGHT', 'knight', 'rare'),
                    new Ingredient('QUEENwa', 'queen', 'common'),
                    new Ingredient('Ice QUEEN', 'queen', 'common'),
                    new Ingredient('QUEENce', 'queen', 'uncommon'),
                    new Ingredient('QUEEN cuisine', 'queen', 'uncommon'),
                    new Ingredient('Sour queen', 'queen', 'rare'),
                    new Ingredient('Pastor', 'bishop', 'common')
                ];

                this.potionProgress = {
                    'Rook Potion': new Set(),
                    'Bishop Potion': new Set(),
                    'Knight Potion': new Set(),
                    'Queen Potion': new Set()
                };
            }

            getPieceLimits() {
                return this.turnCount <= 30 ? this.pieceLimits.early : this.pieceLimits.late;
            }

            delayNextPlayerMove() {
                this.playerMoveDelayed = true;
                setTimeout(() => {
                    this.playerMoveDelayed = false;
                }, 1000);  // 1 second delay
            }

            getCurrentPieceCounts() {
                const counts = { Q: 0, R: 0, B: 0, N: 0 };
                for (const [row, col] of this.enemies) {
                    const piece = this.board[row][col];
                    if (piece && piece.pieceType in counts) {
                        counts[piece.pieceType]++;
                    }
                }
                return counts;
            }

            findBestPawnToMove() {
                let bestPawn = null;
                let closestToPromotion = null;
                let minDistanceToPromotion = Infinity;

                for (const [row, col] of this.enemies) {
                    const piece = this.board[row][col];
                    if (piece && piece.pieceType === 'p') {
                        const validMoves = this.getValidMoves(row, col);
                        
                        // Check if pawn can move within 2 squares of the player
                        const canThreatenPlayer = validMoves.some(([moveRow, moveCol]) => 
                            Math.abs(moveRow - this.selectedPos[0]) <= 2 && 
                            Math.abs(moveCol - this.selectedPos[1]) <= 2
                        );

                        // Check if pawn can protect another piece
                        const canProtectPiece = this.enemies.some(([enemyRow, enemyCol]) => 
                            enemyRow !== row && enemyCol !== col && 
                            validMoves.some(([moveRow, moveCol]) => 
                                Math.abs(moveRow - enemyRow) <= 1 && 
                                Math.abs(moveCol - enemyCol) <= 1
                            )
                        );

                        if (canThreatenPlayer || canProtectPiece) {
                            bestPawn = [row, col];
                            break;
                        }

                        // Track the pawn closest to promotion
                        const distanceToPromotion = piece.direction === 1 ? (ROWS - 1 - row) : row;
                        if (distanceToPromotion < minDistanceToPromotion) {
                            minDistanceToPromotion = distanceToPromotion;
                            closestToPromotion = [row, col];
                        }
                    }
                }

                return bestPawn || closestToPromotion;
            }

            promotePawnRandom(row, col) {
                const limits = this.getPieceLimits();
                const counts = this.getCurrentPieceCounts();
                
                let newPieceType;
                if (counts['Q'] < limits['Q']) {
                    newPieceType = 'Q';
                } else {
                    const validOptions = Object.keys(limits).filter(piece => counts[piece] < limits[piece] && piece !== 'Q');
                    newPieceType = validOptions[Math.floor(Math.random() * validOptions.length)];
                }
                
                this.board[row][col] = new Piece('b', newPieceType);
                console.log(`Pawn promoted to ${newPieceType} at [${row}, ${col}]`);
                
                // Add pop-up text
                this.addPopUp(`Pawn Promoted to ${newPieceType}`, 'gold', 3000, 3);
            }

            promotePawnWithPopup(row, col) {
                const promotionOptions = ['Q', 'R', 'B', 'N'];
                
                const popupDiv = document.createElement('div');
                popupDiv.id = 'promotionPopup';
                popupDiv.style.cssText = `
                    position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
                    background-color: rgba(0, 0, 0, 0.8); color: white; padding: 20px;
                    border-radius: 10px; z-index: 1000;
                `;
                popupDiv.innerHTML = '<h2>Choose promotion:</h2>';

                promotionOptions.forEach(option => {
                    const button = document.createElement('button');
                    button.textContent = option;
                    button.onclick = () => {
                        this.board[row][col] = new Piece('b', option);
                        document.body.removeChild(popupDiv);
                        this.resumeGameAfterPromotion();
                    };
                    popupDiv.appendChild(button);
                });

                document.body.appendChild(popupDiv);
                this.pauseGameForPromotion();
            }

            promotePawnRandom(row, col) {
                const limits = this.getPieceLimits();
                const counts = this.getCurrentPieceCounts();
                let validOptions = Object.keys(limits).filter(piece => counts[piece] < limits[piece]);
                
                // Prevent queen promotion before turn 20
                if (this.turnCount < 20) {
                    validOptions = validOptions.filter(piece => piece !== 'Q');
                }
                
                let newPieceType;
                if (validOptions.length > 0) {
                    newPieceType = validOptions[Math.floor(Math.random() * validOptions.length)];
                } else {
                    // If all pieces are at their limits, default to a knight
                    newPieceType = 'N';
                }
                
                this.board[row][col] = new Piece('b', newPieceType);
                console.log(`Pawn promoted to ${newPieceType} at [${row}, ${col}]`);
                
                // Add pop-up text
                this.addPopUp("Pawn Promoted", 'gold', 3000, 3);
            }

            pauseGameForPromotion() {
                // Implement logic to pause the game
                // This could involve setting a flag to prevent further moves
                this.isPaused = true;
            }

            resumeGameAfterPromotion() {
                // Implement logic to resume the game
                this.isPaused = false;
                // Trigger any necessary updates or redraws
                this.draw(ctx);
            }

            updateDifficulty() {
                const enemyCount = this.enemies.length;
                const potionCount = Array.from(this.unlockedPotions).length;
                
                if (this.turnCount <= 30) {
                    this.difficultyLevel = 0;
                } else if (this.turnCount <= 50) {
                    this.difficultyLevel = 1;
                } else if (this.turnCount <= 80) {
                    this.difficultyLevel = 2;
                } else {
                    this.difficultyLevel = 3;
                }

                // Adjust spawn rates based on difficulty
                this.updateSpawnRates();

                // Change spawn mode based on difficulty
                this.updateSpawnMode();
            }

            updateSpawnRates() {
                const baseRates = {
                    'p': 0.60,
                    'N': 0.25,
                    'B': 0.20,
                    'R': 0.20,
                    'Q': 0.05
                };

                const difficultyMultiplier = 1 + (this.difficultyLevel * 0.1);

                for (const piece in this.spawnRates) {
                    this.spawnRates[piece] = Math.min(baseRates[piece] * difficultyMultiplier, 1);
                }
            }

            updateSpawnMode() {
                const modes = [
                    "white border only",
                    "black border only",
                    "white and black border",
                    "farthest"
                ];
                this.spawnMode = modes[this.difficultyLevel];
            }





            setRevealAllPieces(reveal) {
                this.revealAllPieces = reveal;
            }

            revealAllPieces() {
                this.peekActivated = true;
            }

            addAnimation(type, from, to, piece, duration = 300) {
                this.animations.push(new Animation(type, from, to, piece, duration));
            }

            clearHighlights() {
                this.lastSpawned = null;
                this.lastMovedEnemyFrom = null;
                this.lastMovedEnemyTo = null;
                this.hoverPos = null;
            }

            processAnimationQueue() {
                if (this.animationQueue.length === 0) {
                    this.isAnimating = false;
                    return;
                }

                this.isAnimating = true;
                const animation = this.animationQueue.shift();
                animation(() => {
                    this.processAnimationQueue();
                });
            }

            createMoveAnimation(fromRow, fromCol, toRow, toCol, piece, duration = 300) {
                return (callback) => {
                    piece.isAnimating = true;
                    const startTime = performance.now();
                    const animate = (currentTime) => {
                        const elapsed = currentTime - startTime;
                        const progress = Math.min(elapsed / duration, 1);
                        
                        const currentX = fromCol * SQUARE_SIZE + (toCol - fromCol) * SQUARE_SIZE * progress;
                        const currentY = fromRow * SQUARE_SIZE + (toRow - fromRow) * SQUARE_SIZE * progress;
                        
                        drawBoard(ctx);
                        this.draw(ctx);
                        
                        // Draw motion blur
                        ctx.save();
                        ctx.globalAlpha = 0.3;
                        for (let i = 1; i <= 5; i++) {
                            const blurProgress = Math.max(0, progress - i * 0.05);
                            const blurX = fromCol * SQUARE_SIZE + (toCol - fromCol) * SQUARE_SIZE * blurProgress;
                            const blurY = fromRow * SQUARE_SIZE + (toRow - fromRow) * SQUARE_SIZE * blurProgress;
                            piece.draw(ctx, blurY / SQUARE_SIZE, blurX / SQUARE_SIZE);
                        }
                        ctx.restore();
                        
                        // Draw the actual piece
                        piece.draw(ctx, currentY / SQUARE_SIZE, currentX / SQUARE_SIZE);
                        
                        if (progress < 1) {
                            requestAnimationFrame(animate);
                        } else {
                            piece.isAnimating = false;
                            callback();
                        }
                    };
                    requestAnimationFrame(animate);
                };
            }

            createSpawnAnimation(row, col, piece, duration = 500, isPlayerPiece = false) {
                return (callback) => {
                    piece.isAnimating = true;
                    const startTime = performance.now();
                    const animate = (currentTime) => {
                        const elapsed = currentTime - startTime;
                        const progress = Math.min(elapsed / duration, 1);
                        
                        drawBoard(ctx);
                        this.draw(ctx);
                        
                        let x, y;
                        if (isPlayerPiece) {
                            // Animate from off-screen
                            x = col * SQUARE_SIZE;
                            y = (row + 1 - progress) * SQUARE_SIZE;
                        } else {
                            x = col * SQUARE_SIZE;
                            y = row * SQUARE_SIZE;
                            ctx.globalAlpha = progress;
                        }
                        
                        piece.draw(ctx, y / SQUARE_SIZE, x / SQUARE_SIZE);
                        ctx.globalAlpha = 1;
                        
                        if (progress < 1) {
                            requestAnimationFrame(animate);
                        } else {
                            piece.isAnimating = false;
                            callback();
                        }
                    };
                    requestAnimationFrame(animate);
                };
            }

            executeAnimations() {
                if (this.animations.length === 0) {
                    // Apply all pending moves
                    for (const move of this.pendingMoves) {
                        move();
                    }
                    this.pendingMoves = [];
                    return Promise.resolve();
                }

                return new Promise(resolve => {
                    const animate = (currentTime) => {
                        drawBoard(ctx);
                        this.draw(ctx);

                        let allFinished = true;
                        for (const animation of this.animations) {
                            const progress = animation.update(currentTime);
                            animation.draw(ctx, progress);
                            if (progress < 1) allFinished = false;
                        }

                        if (allFinished) {
                            this.animations = [];
                            // Apply all pending moves
                            for (const move of this.pendingMoves) {
                                move();
                            }
                            this.pendingMoves = [];
                            resolve();
                        } else {
                            requestAnimationFrame(animate);
                        }
                    };
                    requestAnimationFrame(animate);
                });
            }



            handleMouseMove(x, y) {
                const [row, col] = getRowColFromMouse([x, y]);
                if (row >= 0 && row < ROWS && col >= 0 && col < COLS) {
                    this.hoverPos = [row, col];
                } else {
                    this.hoverPos = null;
                }
            }

            getGameStats() {
                return {
                    ingredientsCollected: this.ingredientsCollected,
                    potionsUsed: this.potionsUsed,
                    emergencyTurnsUsed: this.emergencyTurnsUsed,
                    piecesCaptured: this.piecesCaptured
                };
            }
            
            getState() {
                return {
                    board: this.board.map(row => row.map(piece => 
                        piece ? { color: piece.color, pieceType: piece.pieceType } : null
                    )),
                    playerPiece: this.playerPiece ? { color: this.playerPiece.color, pieceType: this.playerPiece.pieceType } : { color: 'w', pieceType: 'K' },
                    selectedPos: [...this.selectedPos],
                    enemies: this.enemies.map(enemy => [...enemy]),
                    turnCount: this.turnCount,
                    score: this.score,
                    revealAllPieces: this.revealAllPieces,
                    peekActivated: this.peekActivated
                    // ... any other relevant state ...
                };
            }

            setState(state) {
                if (!state) {
                    console.error('Cannot set state: state is undefined');
                    return;
                }

                this.board = state.board.map(row => row.map(piece => 
                    piece ? new Piece(piece.color, piece.pieceType) : null
                ));

                if (state.playerPiece) {
                    this.playerPiece = new Piece(state.playerPiece.color, state.playerPiece.pieceType);
                } else {
                    console.warn('Player piece is missing in the provided state, creating default King');
                    this.playerPiece = new Piece('w', 'K');
                }

                this.selectedPos = state.selectedPos ? [...state.selectedPos] : [0, 0];
                this.enemies = state.enemies ? state.enemies.map(enemy => [...enemy]) : [];
                this.turnCount = state.turnCount || 0;
                this.score = state.score || 0;
                this.revealAllPieces = state.revealAllPieces;
                this.peekActivated = state.peekActivated;
                // ... restore any other relevant state ...
            }

            usePotion(potionType) {
                const potionName = potionType + ' Potion';
                if (this.unlockedPotions.has(potionName)) {
                    const recipe = this.recipes.find(r => r.name === potionName);
                    if (recipe) {
                        // Remove used ingredients
                        for (let i = 0; i < recipe.requiredCount; i++) {
                            const ingredientIndex = this.collectedIngredients.findIndex(
                                ing => recipe.ingredients.includes(ing.name)
                            );
                            if (ingredientIndex !== -1) {
                                this.collectedIngredients.splice(ingredientIndex, 1);
                            }
                        }
                    }

                    this.potionsUsed++;

                    this.unlockedPotions.delete(potionName);
                    const pieceTypeMap = {
                        'Rook': 'R',
                        'Bishop': 'B',
                        'Knight': 'N',
                        'Queen': 'Q'
                    };
                    const pieceType = pieceTypeMap[potionType];
                    this.changePlayerPiece(pieceType);
                    //this.addPopUp(`Changed to ${potionType}!`, [GAME_SIZE / 2, GAME_SIZE / 2], [0, 255, 0], 80);
                    this.addPopUp(`Changed to ${potionType}!`, 'purple', 3000, 3);

                    // Reset the progress for this potion
                    this.potionProgress[potionName].clear();

                    this.updatePotionUI();
                    this.justUsedPotion = true;
                } else {
                    console.log(`${potionName} is not available`);
                }
            }

            // changePlayerPiece(pieceType) {
            //     if (pieceType === this.playerPiece.pieceType) {
            //         console.log(`Already ${pieceType}, no change needed`);
            //         return;
            //     }

            //     this.playerPiece = new Piece('w', pieceType);
            //     this.board[this.selectedPos[0]][this.selectedPos[1]] = this.playerPiece;
            //     console.log(`Piece changed to ${pieceType}`);
            //     this.updatePotionUI();
            // }

            spawnIngredient() {
                if (this.ingredients.length < 2 && (this.turnCount === 1 || this.turnCount - this.lastIngredientSpawn >= 5)) {
                    const emptySquares = this.getEmptySquares();
                    if (emptySquares.length > 0) {
                        const [row, col] = emptySquares[Math.floor(Math.random() * emptySquares.length)];
                        const randomIngredient = this.getRandomIngredient();
                        this.ingredients.push(new Ingredient(randomIngredient.name, randomIngredient.type, randomIngredient.rarity, row, col));
                        this.lastIngredientSpawn = this.turnCount;
                        console.log(`Spawned ingredient at [${row}, ${col}]. Total ingredients: ${this.ingredients.length}`);
                    }
                }
            }

            getEmptySquares() {
                const emptySquares = [];
                for (let row = 0; row < ROWS; row++) {
                    for (let col = 0; col < COLS; col++) {
                        if (this.board[row][col] === null &&
                            !this.ingredients.some(ing => ing.row === row && ing.col === col) &&
                            (row !== this.selectedPos[0] || col !== this.selectedPos[1])) {
                            emptySquares.push([row, col]);
                        }
                    }
                }
                return emptySquares;
            }

            updateIngredients() {
                this.ingredients = this.ingredients.filter(ingredient => {
                    const expired = ingredient.decreaseLifespan();
                    if (expired) {
                        console.log(`Ingredient at [${ingredient.row}, ${ingredient.col}] has expired.`);
                    }
                    return !expired;
                });
            }

            forceSpawnIngredient() {
                const emptySquares = [];
                for (let row = 0; row < ROWS; row++) {
                    for (let col = 0; col < COLS; col++) {
                        if (this.board[row][col] === null &&
                            !this.ingredients.some(ing => ing.row === row && ing.col === col) &&
                            (row !== this.selectedPos[0] || col !== this.selectedPos[1])) {
                            emptySquares.push([row, col]);
                        }
                    }
                }
                if (emptySquares.length > 0) {
                    const [row, col] = emptySquares[Math.floor(Math.random() * emptySquares.length)];
                    this.ingredients.push({row, col}); // Just store position, actual ingredient determined on collection
                    this.lastIngredientSpawn = this.turnCount;
                    console.log(`Spawned ingredient at [${row}, ${col}]. Total ingredients: ${this.ingredients.length}`);
                } else {
                    console.log('No empty squares available for ingredient spawn');
                }
            }

            collectIngredient(row, col) {
                const index = this.ingredients.findIndex(ing => ing.row === row && ing.col === col);
                if (index !== -1) {
                    const ingredient = this.ingredients[index];
                    this.collectedIngredients.push(ingredient);
                    this.ingredients.splice(index, 1);
                    this.ingredientsCollected++;
                    this.addPopUp(`Collected: ${ingredient.name}`, ingredient.getColor(), 3000, 2);
                    this.lastIngredientSpawn = this.turnCount;
                    this.updatePotionProgress(ingredient);
                    this.checkPotionUnlocks();
                    console.log(`Ingredient collected: ${ingredient.name}. Total: ${this.ingredientsCollected}. Next spawn in 5 turns.`);
                }
            }

            getRandomIngredient() {
                return this.allIngredients[Math.floor(Math.random() * this.allIngredients.length)];
            }

            updatePotionProgress(ingredient) {
                if (!ingredient || typeof ingredient !== 'object' || !ingredient.name) {
                    console.error('Invalid ingredient:', ingredient);
                    return; // Exit the function if the ingredient is invalid
                }
                this.recipes.forEach(recipe => {
                    if (recipe.ingredients.includes(ingredient.name)) {
                        this.potionProgress[recipe.name].add(ingredient.name);
                    }
                });
                this.checkPotionUnlocks();
                this.updatePotionUI();
            }

            updatePotionUI() {
                const potionInfo = {
                    'Rook': { required: 3, unique: this.potionProgress['Rook Potion'].size },
                    'Bishop': { required: 3, unique: this.potionProgress['Bishop Potion'].size },
                    'Knight': { required: 2, unique: this.potionProgress['Knight Potion'].size },
                    'Queen': { required: 5, unique: this.potionProgress['Queen Potion'].size }
                };

                for (const [potionType, info] of Object.entries(potionInfo)) {
                    const buttonId = 'use' + potionType + 'Potion';
                    const button = document.getElementById(buttonId);
                    if (button) {
                        const potionName = potionType + ' Potion';
                        const availableCount = this.getAvailablePotionCount(potionName);
                        const isAvailable = availableCount > 0;
                        
                        button.disabled = !isAvailable;
                        button.textContent = isAvailable 
                            ? `Use ${potionType} Potion (${availableCount})`
                            : `${potionType} Ingredients: ${info.unique} of ${info.required}`;
                        button.classList.toggle('potionButton-available', isAvailable);
                        
                        // Set tooltip with ingredient names
                        const recipe = this.recipes.find(r => r.name === potionName);
                        if (recipe) {
                            button.title = recipe.ingredients.join(', ');
                        }
                    }
                }
            }

            getAvailablePotionCount(potionName) {
                const recipe = this.recipes.find(r => r.name === potionName);
                if (!recipe) return 0;
                
                const relevantIngredients = this.collectedIngredients.filter(ing => recipe.ingredients.includes(ing.name));
                return Math.floor(relevantIngredients.length / recipe.requiredCount);
            }

            checkPotionUnlocks() {
                this.recipes.forEach(recipe => {
                    const availableCount = this.getAvailablePotionCount(recipe.name);
                    if (availableCount > 0 && !this.unlockedPotions.has(recipe.name)) {
                        this.unlockedPotions.add(recipe.name);
                        //this.popUpTexts.push(new PopUpText(`${recipe.name} Available`, [GAME_SIZE / 2, GAME_SIZE / 2], [0, 255, 0], 80));
                        this.addPopUp(`${recipe.name} Available`, 'rgba(128, 0, 128, 0.7)', 3000, 0);
                        console.log(`${recipe.name} unlocked!`);
                    }
                });
            }

            draw(ctx) {
                for (let row = 0; row < ROWS; row++) {
                    for (let col = 0; col < COLS; col++) {
                        const piece = this.board[row][col];
                        if (piece && !piece.isAnimating) {
                            if (this.revealAllPieces || piece.color === 'w' || this.isWhiteSquare(row, col) || this.peekActivated) {
                                piece.draw(ctx, row, col);
                            }
                        }
                    }
                }
                this.drawIngredients(ctx);
                this.highlightLastSpawned(ctx);
                this.highlightLastMovedEnemy(ctx);
                this.highlightPlayer(ctx);
                if (this.showDots) {
                    this.drawValidMoves(ctx);
                }
                this.drawHoverHighlight(ctx);
            }

            drawHoverHighlight(ctx) {
                if (this.hoverPos) {
                    const [row, col] = this.hoverPos;
                    const { safeMoves, unsafeMoves } = this.getAllValidMoves();
                    const allMoves = [...safeMoves, ...unsafeMoves];

                    if (allMoves.some(move => move[0] === row && move[1] === col)) {
                        ctx.lineWidth = 12;
                        if (safeMoves.some(move => move[0] === row && move[1] === col)) {
                            ctx.strokeStyle = 'rgba(0, 0, 255, 0.7)'; // Green for safe moves
                        } else {
                            ctx.strokeStyle = 'rgba(0, 0, 255, 0.7)'; // Yellow for unsafe moves
                        }
                        ctx.strokeRect(col * SQUARE_SIZE, row * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE);
                    }
                }
            }

            checkPieceAvailability(previousScore, currentScore) {
                const milestones = [
                    {score: 25, piece: 'Queen'},
                    {score: 18, piece: 'Bishop'},
                    {score: 17, piece: 'Rook'},
                    {score: 15, piece: 'Knight'}
                ];

                for (const milestone of milestones) {
                    if (previousScore < milestone.score && currentScore >= milestone.score) {
                        return milestone.piece;
                    }
                }
                return null;
            }

            isWhiteSquare(row, col) {
                return (row + col) % 2 === 0;
            }

            changePlayerPiece(pieceType) {
                console.log(`Changing player piece to: ${pieceType}`);
                const oldPiece = this.playerPiece;
                this.playerPiece = new Piece('w', pieceType);
                
                const [row, col] = this.selectedPos;
                
                // Add animation for the new piece coming from off-screen
                this.addAnimation(this.createSpawnAnimation(row, col, this.playerPiece, 500, true));
                
                this.board[row][col] = this.playerPiece;
                console.log(`Piece changed to ${pieceType}`);
                this.updatePotionUI();
            }

            updatePieceButtons() {
                const kingButton = document.getElementById('changeToK');
                if (kingButton) {
                    kingButton.disabled = false;
                }
                // Disable or enable potion buttons based on availability
                ['Rook', 'Bishop', 'Knight', 'Queen'].forEach(pieceType => {
                    const button = document.getElementById(`use${pieceType}Potion`);
                    if (button) {
                        button.disabled = !this.unlockedPotions.has(`${pieceType} Potion`);
                    }
                });
            }

            captureEnemyIfPresent(row, col) {
                if (this.board[row][col] !== null && this.board[row][col].color === 'b') {
                    const capturedPiece = this.board[row][col];
                    const points = {'N': 5, 'B': 8, 'R': 7, 'Q': 15, 'p': 1}[capturedPiece.pieceType] || 1;
                    this.score += points;
                    this.enemies = this.enemies.filter(enemy => !(enemy[0] === row && enemy[1] === col));

                    const pieceName = {'p': 'Pawn', 'R': 'Rook', 'N': 'Knight', 'B': 'Bishop', 'Q': 'Queen', 'K': 'King'}[capturedPiece.pieceType] || 'Unknown';
                    const popUpText = `+${points} ${pieceName} Taken`;
                    this.addPopUp(popUpText, 'gold', 3000, 3); // High priority

                    this.giveIngredientForCapture(capturedPiece.pieceType);

                    console.log(`Captured ${pieceName} at [${row}, ${col}]`);
                    this.piecesCaptured++;
                }
            }

            giveIngredientForCapture(capturedPieceType) {
                let ingredient = this.getRandomIngredientForPieceType(capturedPieceType);
                if (!ingredient) {
                    console.error(`No ingredient found for piece type: ${capturedPieceType}`);
                    return; // Exit the function if no ingredient is found
                }
                this.collectedIngredients.push(ingredient);
                this.ingredientsCollected++;
                this.updatePotionProgress(ingredient);

                this.addPopUp(`Got: ${ingredient.name}`, 'blue', 3000, 1);
                updateGameInfo(this);
            }

            getRandomIngredientForPieceType(pieceType) {
                let type;
                switch(pieceType) {
                    case 'R': type = 'rook'; break;
                    case 'B': type = 'bishop'; break;
                    case 'N': type = 'knight'; break;
                    case 'Q': type = 'queen'; break;
                    default: type = null;
                }
                
                if (!type) {
                    console.warn(`No specific ingredient type for piece: ${pieceType}. Using random ingredient.`);
                    return this.getRandomIngredient();
                }

                const ingredientsOfType = this.allIngredients.filter(ing => ing.type === type);
                if (ingredientsOfType.length === 0) {
                    console.warn(`No ingredients found for type: ${type}. Using random ingredient.`);
                    return this.getRandomIngredient();
                }
                return ingredientsOfType[Math.floor(Math.random() * ingredientsOfType.length)];
            }

            resetEnemyJustSpawnedFlags() {
                for (const enemy of this.enemies) {
                    const [row, col] = enemy;
                    const piece = this.board[row][col];
                    if (piece) {
                        piece.justSpawned = false;
                    }
                }
            }

            movePlayer(row, col) {
                if (this.playerMoveDelayed) {
                    console.log("Please wait a moment before your next move.");
                    return false;
                }

                this.turnPopUps = [];
                this.saveState();
                const initialScore = this.score;
                const validMoves = this.getValidMoves(...this.selectedPos);
                const isValidMove = validMoves.some(move => move[0] === row && move[1] === col);

                // Check if the clicked position is the player's current position
                if (row === this.selectedPos[0] && col === this.selectedPos[1]) {
                    console.log('Player clicked on their own piece. No move made.');
                    return true; // Return true to indicate the game should continue
                }

                if (isValidMove) {
                    console.log(`Attempting to move to [${row}, ${col}]. Valid move: ${isValidMove}`);
                    try {
                        this.executeMove(row, col, initialScore);

                        // Deactivate hint after player's move
                        this.showDots = false;
                        
                        // Change player piece back to King if a potion was used
                        if (this.playerPiece.pieceType !== 'K') {
                            this.changePlayerPiece('K');
                            this.addPopUp("Changed back to King", 'green', 3000, 4);
                        }
                        
                        this.processTurnPopUps();
                        
                        this.delayNextPlayerMove();
                        return true;
                    } catch (error) {
                        console.log(`Error during move: ${error.message}`);
                        console.error(error);
                        return false;
                    }
                } else {
                    console.log('Invalid move attempted');
                }
                return true; // Return true to indicate the game should continue even if the move was invalid
            }

            getPotionTypeForMove(row, col) {
                for (const potionType of ['Rook', 'Bishop', 'Knight', 'Queen']) {
                    if (this.unlockedPotions.has(potionType + ' Potion')) {
                        const tempPiece = new Piece('w', potionType[0]);
                        const potionMoves = tempPiece.getPossibleMoves(...this.selectedPos)
                            .filter(([r, c]) => r >= 0 && r < ROWS && c >= 0 && c < COLS);
                        if (potionMoves.some(move => move[0] === row && move[1] === col)) {
                            return potionType;
                        }
                    }
                }
                return null;
            }

            async executeMove(row, col, initialScore) {
                this.clearHighlights();
                // ... existing code ...
                this.captureEnemyIfPresent(row, col);
                this.movePlayerPiece(row, col);
                this.handlePendingPieceChange();

                if (!this.emergencyMove) {
                    this.incrementTurnAndScore();
                    this.updateIngredients();
                    this.spawnIngredient();
                }

                await this.executeAnimations(); // Wait for player move animation

                console.log("\nAfter player move:");
                this.printBoardState();
                this.handlePeekDeactivation();
                this.collectIngredient(row, col);

                if (this.checkEmergencyMove()) {
                    return;
                }
                if (!this.processEnemyMoves()) {
                    console.log('Game over: Player captured');
                    return;
                }

                await this.executeAnimations(); // Wait for enemy move animations

                console.log("\nAfter enemy moves:");
                this.printBoardState();
                this.handleEnemySpawning();
                
                await this.executeAnimations(); // Wait for enemy spawn animation

                this.resetEnemyJustSpawnedFlags();
                this.updateUI(initialScore);
            }

            movePlayerPiece(row, col) {
                const [fromRow, fromCol] = this.selectedPos;
                this.addAnimation('move', [fromRow, fromCol], [row, col], this.playerPiece);
                this.pendingMoves.push(() => {
                    this.board[fromRow][fromCol] = null;
                    this.selectedPos = [row, col];
                    this.board[row][col] = this.playerPiece;
                });
            }

            handlePendingPieceChange() {
                if (this.pendingPieceChange) {
                    this.changePlayerPiece(this.pendingPieceChange);
                    this.pendingPieceChange = null;
                }
            }

            incrementTurnAndScore() {
                ++this.turnCount;
                ++this.score;
                this.spawnIngredient();
            }

            handlePeekDeactivation() {
                if (this.peekActivated) {
                    this.peekActivated = false;
                    this.updatePeekButton();
                }
            }

            // handleNewPieceAvailability(initialScore, row, col) {
            //     const newPieceAvailable = this.checkPieceAvailability(initialScore, this.score);
            //     if (newPieceAvailable) {
            //         this.popUpTexts.push(new PopUpText(`${newPieceAvailable} Available`, [col * SQUARE_SIZE, row * SQUARE_SIZE], [0, 255, 0], 40));
            //     }
            // }

            checkEmergencyMove() {
                if (!this.hasSafeMoves() && !this.emergencyMove) {
                    this.emergencyMove = true;
                    this.emergencyTurnsUsed++;
                    console.log('Emergency move activated! Player can move again.');
                    return true;
                }
                if (this.emergencyMove) {
                    this.emergencyMove = false;
                    return true;
                }

                return false;
            }

            processEnemyMoves() {
                return this.moveEnemies();
            }

            handleEnemySpawning() {
                if (this.turnCount >= 2) {
                    this.spawnEnemy();
                    console.log("\nAfter spawning enemy:");
                    this.printBoardState();
                }
            }

            updateUI(initialScore) {
                this.lastMoveScoreGain = this.score - initialScore;
                this.updatePieceButtons();
                updateGameInfo(this);

                const hintButton = document.getElementById('toggleDotsButton');
                if (hintButton) {
                    hintButton.disabled = this.score < 10 || this.showDots;
                }
            }


            resetPieceChange() {
                this.lastPieceChange = null;
            }

            saveState() {
                this.previousState = {
                    board: this.board.map(row => [...row]),
                    selectedPos: [...this.selectedPos],
                    enemies: this.enemies.map(enemy => [...enemy]),
                    turnCount: this.turnCount,
                    score: this.score,
                    emergencyMove: this.emergencyMove,
                    playerPieceType: this.playerPiece.pieceType,
                    ingredients: [...this.ingredients],
                    collectedIngredients: [...this.collectedIngredients],
                    ingredientsCollected: this.ingredientsCollected
                };
                this.canUndo = true;
                this.lastMoveScoreGain = 0;
            }

            undoMove() {
                if (!this.canUndo) {
                    console.log('Cannot undo. No previous state available.');
                    return false;
                }

                // Restore the board state
                this.board = this.previousState.board;
                this.selectedPos = this.previousState.selectedPos;
                this.enemies = this.previousState.enemies;
                this.turnCount = this.previousState.turnCount;
                this.emergencyMove = this.previousState.emergencyMove;

                // Restore the player piece
                this.playerPiece = new Piece('w', this.previousState.playerPieceType);
                this.board[this.selectedPos[0]][this.selectedPos[1]] = this.playerPiece;

                // Restore ingredients
                this.ingredients = [...this.previousState.ingredients];
                this.collectedIngredients = [...this.previousState.collectedIngredients];
                this.ingredientsCollected = this.previousState.ingredientsCollected;

                // Adjust the score, ensuring it doesn't go below zero
                this.score = Math.max(0, this.previousState.score);

                this.canUndo = false;
                console.log(`Move undone. Reverted to ${this.playerPiece.pieceType} and adjusted score to ${this.score}.`);

                // Update potion UI after undoing
                this.updatePotionProgress();
                this.checkPotionUnlocks();
                this.updatePotionUI();

                return true;
            }

            adjustScore(change) {
                this.score = Math.max(0, this.score + change);
            }



            isMoveSafe(startPos, endPos, ignorePlayerPos = false) {
                const [startRow, startCol] = startPos;
                const [endRow, endCol] = endPos;
                const piece = this.board[startRow][startCol];
                const originalEndPiece = this.board[endRow][endCol];
                
                // Temporarily move the piece
                this.board[endRow][endCol] = piece;
                this.board[startRow][startCol] = null;
                
                let isSafe = true;
                const originalPlayerPos = [...this.selectedPos];
                
                if (ignorePlayerPos) {
                    // Temporarily remove the player from the board
                    this.board[this.selectedPos[0]][this.selectedPos[1]] = null;
                }
                
                // Check if any enemy can attack this position
                for (const enemy of this.enemies) {
                    const [row, col] = enemy;
                    const enemyPiece = this.board[row][col];
                    if (enemyPiece) {
                        const enemyMoves = this.getValidMoves(row, col, enemyPiece);
                        if (enemyMoves.some(move => move[0] === endRow && move[1] === endCol)) {
                            isSafe = false;
                            break;
                        }
                    }
                }
                
                // Restore the board state
                this.board[startRow][startCol] = piece;
                this.board[endRow][endCol] = originalEndPiece;
                if (ignorePlayerPos) {
                    this.board[originalPlayerPos[0]][originalPlayerPos[1]] = this.playerPiece;
                }
                
                return isSafe;
            }

            hasSafeMoves() {
                for (const pieceType of ['K', 'N', 'B', 'R', 'Q']) {
                    const originalPiece = this.playerPiece;
                    this.playerPiece = new Piece('w', pieceType);
                    const validMoves = this.getValidMoves(...this.selectedPos);
                    if (validMoves.some(move => this.isMoveSafe(this.selectedPos, move))) {
                        this.playerPiece = originalPiece;
                        return true;
                    }
                    this.playerPiece = originalPiece;
                }
                return false;
            }

            isPositionProtected(position, attackingColor) {
                for (let row = 0; row < ROWS; row++) {
                    for (let col = 0; col < COLS; col++) {
                        const piece = this.board[row][col];
                        if (piece && piece.color === attackingColor) {
                            const validMoves = this.getValidMoves(row, col);
                            if (validMoves.some(move => move[0] === position[0] && move[1] === position[1])) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            }

            resetHighlights() {
                this.lastSpawned = null;
                this.lastMovedEnemyFrom = null;
                this.lastMovedEnemyTo = null;
            }

            draw(ctx) {
                for (let row = 0; row < ROWS; row++) {
                    for (let col = 0; col < COLS; col++) {
                        const piece = this.board[row][col];
                        if (piece && !piece.isAnimating) {
                            const isVisible = this.revealAllPieces || piece.color === 'w' || 
                                            this.isWhiteSquare(row, col) || this.peekActivated || 
                                            piece.forceVisible;
                            
                            if (isVisible) {
                                piece.draw(ctx, row, col);
                                
                                // Draw pawn direction indicator
                                if (piece.pieceType === 'p' && piece.color === 'b') {
                                    this.drawPawnDirectionIndicator(ctx, row, col, piece.direction);
                                }
                            }
                        }
                    }
                }

                this.drawIngredients(ctx);
                if (this.lastSpawned) {
                    this.highlightLastSpawned(ctx);
                }
                if (this.lastMovedEnemyFrom && this.lastMovedEnemyTo) {
                    this.highlightLastMovedEnemy(ctx);
                }
                if (!this.isGameOver) {
                    this.highlightPlayer(ctx);
                }
                if (this.showDots && !this.isGameOver) {
                    this.drawValidMoves(ctx);
                }
                if (this.hoverPos && !this.isGameOver) {
                    this.drawHoverHighlight(ctx);
                }

                // Draw animations
                for (const animation of this.animations) {
                    animation.draw(ctx, animation.update(performance.now()));
                }
            }

            drawPieces(ctx) {
                for (let row = 0; row < ROWS; row++) {
                    for (let col = 0; col < COLS; col++) {
                        const piece = this.board[row][col];
                        if (!piece) {
                            continue;
                        }
                        const isWhiteSquare = this.isWhiteSquare(row, col);
                        if (piece.color === 'w' || isWhiteSquare || (piece.color === 'b' && !isWhiteSquare && this.peekActivated)) {
                            piece.draw(ctx, row, col);
                        }
                    }
                }
            }


            drawIngredients(ctx) {
                this.ingredients.forEach(ing => {
                    const x = (ing.col + 0.5) * SQUARE_SIZE;
                    const y = (ing.row + 0.5) * SQUARE_SIZE;

                    ctx.fillStyle = ing.getColor();
                    ctx.beginPath();
                    ctx.arc(x, y, SQUARE_SIZE / 4, 0, 2 * Math.PI);
                    ctx.fill();

                    ctx.fillStyle = 'white';
                    ctx.font = `${SQUARE_SIZE / 2}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('?', x, y);
                });
            }

            highlightLastSpawned(win) {
                if (this.lastSpawned) {
                    const [row, col] = this.lastSpawned;
                    this.drawHighlight(win, row, col, 'rgba(255, 0, 0, 0.7)', 6);

                }
            }

            highlightLastMovedEnemy(win) {
                if (this.lastMovedEnemyFrom) {
                    const [row, col] = this.lastMovedEnemyFrom;
                    this.drawHighlight(win, row, col, 'rgba(252, 165, 0, 0.7)', 3);
                }
                if (this.lastMovedEnemyTo) {
                    const [row, col] = this.lastMovedEnemyTo;
                    this.drawHighlight(win, row, col, 'rgba(252, 165, 0, 0.7)', 5);
                }
            }

            highlightPlayer(win) {
                const playerColor = this.emergencyMove ? 'green' : 'blue';
                this.drawHighlight(win, this.selectedPos[0], this.selectedPos[1], playerColor, 5);
            }

            drawHighlight(win, row, col, color, lineWidth) {
                const squareSize = win.canvas.width / 8; // Assuming 8x8 chess board
                const x = col * squareSize;
                const y = row * squareSize;

                win.strokeStyle = color;
                win.lineWidth = lineWidth * (squareSize / 50); // Scale line width relative to square size
                win.strokeRect(x, y, squareSize, squareSize);
            }



            drawValidMoves(ctx) {
                const { safeMoves, unsafeMoves } = this.getAllValidMoves();

                // Draw safe moves
                for (const [row, col] of safeMoves) {
                    ctx.beginPath();
                    ctx.arc((col + 0.5) * SQUARE_SIZE, (row + 0.5) * SQUARE_SIZE, SQUARE_SIZE / 8, 0, 2 * Math.PI);
                    ctx.fillStyle = 'rgba(0, 255, 0, 0.5)'; // Green for safe moves
                    ctx.fill();
                }

                // Draw unsafe moves
                for (const [row, col] of unsafeMoves) {
                    ctx.beginPath();
                    ctx.arc((col + 0.5) * SQUARE_SIZE, (row + 0.5) * SQUARE_SIZE, SQUARE_SIZE / 8, 0, 2 * Math.PI);
                    ctx.fillStyle = 'rgba(255, 255, 0, 0.5)'; // Yellow for unsafe moves
                    ctx.fill();
                }

                // Draw enemy moves, including pawn attacks
                for (const enemy of this.enemies) {
                    const [row, col] = enemy;
                    const enemyPiece = this.board[row][col];
                    if (enemyPiece) {
                        const enemyMoves = this.getValidMoves(row, col, enemyPiece);
                        for (const [moveRow, moveCol] of enemyMoves) {
                            ctx.beginPath();
                            ctx.arc((moveCol + 0.5) * SQUARE_SIZE, (moveRow + 0.5) * SQUARE_SIZE, SQUARE_SIZE / 8, 0, 2 * Math.PI);
                            ctx.fillStyle = 'rgba(255, 0, 0, 0.5)'; // Red for enemy moves
                            ctx.fill();
                        }
                        
                        // Draw pawn attacks separately
                        if (enemyPiece.pieceType === 'p') {
                            const attackRow = row + enemyPiece.direction;
                            for (const attackCol of [col - 1, col + 1]) {
                                if (attackCol >= 0 && attackCol < COLS && attackRow >= 0 && attackRow < ROWS) {
                                    ctx.beginPath();
                                    ctx.arc((attackCol + 0.5) * SQUARE_SIZE, (attackRow + 0.5) * SQUARE_SIZE, SQUARE_SIZE / 8, 0, 2 * Math.UI);
                                    ctx.fillStyle = 'rgba(255, 0, 0, 0.7)'; // Slightly darker red for pawn attacks
                                    ctx.fill();
                                    
                                    // Draw an X to indicate attack
                                    ctx.arc((attackCol + 0.5) * SQUARE_SIZE, (attackRow + 0.5) * SQUARE_SIZE, SQUARE_SIZE / 8, 0, 2 * Math.PI);
                                    ctx.fillStyle = 'rgba(255, 0, 0, 0.5)'; // Red for enemy moves
                                    ctx.fill();
                                }
                            }
                        }
                    }
                }
            }


            togglePeek() {
                if (this.score >= this.peekCost || this.peekActivated) {
                    if (!this.peekActivated) {
                        this.score -= this.peekCost;
                    }
                    this.peekActivated = !this.peekActivated;
                    console.log(`Peek ${this.peekActivated ? 'activated' : 'deactivated'}`);
                    this.updatePeekButton();
                } else {
                    console.log(`Not enough points to peek. Current score: ${this.score}, Required: ${this.peekCost}`);
                }
            }

            updatePeekButton() {
                const button = document.getElementById('peekButton');
                if (button) {
                    button.textContent = this.peekActivated ? 'Peek Active' : 'Peek (5)';
                    button.disabled = !this.peekActivated && this.score < this.peekCost;
                }
            }

            drawEnemyMoves(win) {
                if (this.showDots) {
                    win.fillStyle = 'red';
                    for (const enemy of this.enemies) {
                        const [row, col] = enemy;
                        const validMoves = this.getValidMoves(row, col);
                        for (const move of validMoves) {
                            const [moveRow, moveCol] = move;
                            win.beginPath();
                            win.arc((moveCol + 0.5) * SQUARE_SIZE, (moveRow + 0.5) * SQUARE_SIZE, SQUARE_SIZE / 8, 0, 2 * Math.PI);
                            win.fill();
                        }
                    }
                }
            }

            toggleDots() {
                const hintCost = 10;
                if (!this.showDots && this.score >= hintCost) {
                    this.showDots = true;
                    this.score -= hintCost;
                    this.addPopUp(`Hint activated (-${hintCost} points)`, 'blue', 2000);
                    setTimeout(() => {
                        this.showDots = false;
                        this.addPopUp('Hint deactivated', 'blue', 2000);
                    }, 5000); // Hint lasts for 5 seconds (adjust as needed)
                } else if (!this.showDots) {
                    this.addPopUp(`Not enough points for hint (${hintCost} needed)`, 'red', 2000);
                }
                this.updateUI();
            }

            moveEnemies() {
                this.spawnIngredient();
                if (this.enemies.length === 0) {
                    return true;
                }

                this.filterEnemies();
                if (this.checkForPlayerCapture()) {
                    return false;
                }

                this.updateAttackingForce();

                if (this.attackingForce.length > 0) {
                    let enemyMoved = false;
                    
                    for (const enemy of this.attackingForce) {
                        const [row, col] = enemy;
                        const piece = this.board[row][col];
                        
                        if (piece && piece.pieceType === 'p') {
                            const bestPawn = this.findBestPawnToMove();
                            if (bestPawn) {
                                enemyMoved = this.executeEnemyMove(bestPawn);
                            }
                        } else {
                            enemyMoved = this.executeEnemyMove(enemy);
                        }

                        if (enemyMoved) break;
                    }
                    
                    // If no enemy could move, move a random enemy
                    if (!enemyMoved && this.enemies.length > 0) {
                        const randomEnemy = this.enemies[Math.floor(Math.random() * this.enemies.length)];
                        this.executeEnemyMove(randomEnemy);
                    }
                }

                this.checkPawnPromotion();
                return true;
            }

            checkPawnPromotion() {
                for (let col = 0; col < COLS; col++) {
                    // Check top row for pawns moving up
                    if (this.board[0][col] && this.board[0][col].pieceType === 'p' && this.board[0][col].direction === -1) {
                        this.promotePawn(0, col);
                    }
                    // Check bottom row for pawns moving down
                    if (this.board[ROWS-1][col] && this.board[ROWS-1][col].pieceType === 'p' && this.board[ROWS-1][col].direction === 1) {
                        this.promotePawn(ROWS-1, col);
                    }
                }
            }

            filterEnemies() {
                this.enemies = this.enemies.filter(enemy => this.board[enemy[0]][enemy[1]] !== null);
            }

            checkForPlayerCapture() {
                for (const enemy of this.enemies) {
                    const captureInfo = this.isPlayerCaptured(enemy);
                    if (captureInfo.captured) {
                        console.log('Game over: Player captured by enemy');
                        this.handleGameOver(captureInfo);
                        return true;
                    }
                }
                return false;
            }

            handleGameOver(captureInfo) {
                const { capturingPiece, capturingPosition, playerPosition } = captureInfo;
                
                this.isGameOver = true;
                this.capturingPiece = capturingPiece;
                this.capturingPosition = playerPosition;

                // Remove the player's piece
                this.board[playerPosition[0]][playerPosition[1]] = null;
                
                // Move the capturing piece to the player's position
                this.board[capturingPosition[0]][capturingPosition[1]] = null;
                this.board[playerPosition[0]][playerPosition[1]] = capturingPiece;
                
                // Update the enemy list
                this.enemies = this.enemies.filter(enemy => 
                    enemy[0] !== capturingPosition[0] || enemy[1] !== capturingPosition[1]
                );
                this.enemies.push(playerPosition);

                // Trigger the game over screen
                gameOver(capturingPiece.pieceType, playerPosition);
            }

            isPlayerCaptured(enemy) {
                const [row, col] = enemy;
                const piece = this.board[row][col];
                if (piece && !piece.justSpawned) {
                    const validMoves = this.getValidMoves(row, col);
                    if (validMoves.some(move => move[0] === this.selectedPos[0] && move[1] === this.selectedPos[1])) {
                        return {
                            captured: true,
                            capturingPiece: piece,
                            capturingPosition: [row, col],
                            playerPosition: [...this.selectedPos]
                        };
                    }
                }
                return { captured: false };
            }

            moveAttackingEnemy() {
                if (this.attackingForce.length > 0) {
                    let enemyMoved = false;
                    for (const enemy of this.attackingForce) {
                        if (this.executeEnemyMove(enemy)) {
                            enemyMoved = true;
                            break;
                        }
                    }
                    
                    // If no enemy could move, move a random enemy
                    if (!enemyMoved && this.enemies.length > 0) {
                        const randomEnemy = this.enemies[Math.floor(Math.random() * this.enemies.length)];
                        this.executeEnemyMove(randomEnemy);
                    }
                }
            }

            executeEnemyMove(enemy) {
                const [row, col] = enemy;
                const piece = this.board[row][col];
                const validMoves = this.getValidMoves(row, col);

                if (validMoves.length > 0) {
                    const newPos = this.getStrategicMove(piece, [row, col], validMoves, enemy === this.mainAttacker);
                    if (newPos) {
                        this.moveEnemyPiece(enemy, newPos);
                        return true;
                    }
                }
                return false;
            }

            chooseEnemyToMove() {
                if (this.mainAttacker && Math.random() < 0.7 && this.attackingForce.some(e => e[0] === this.mainAttacker[0] && e[1] === this.mainAttacker[1])) {
                    return this.mainAttacker;
                }
                return this.attackingForce[Math.floor(Math.random() * this.attackingForce.length)];
            }

            moveEnemyPiece(from, to) {
                this.lastMovedEnemyFrom = from;
                this.lastMovedEnemyTo = to;
                const piece = this.board[from[0]][from[1]];
                this.addAnimation('move', from, to, piece);
                this.pendingMoves.push(() => {
                    this.board[from[0]][from[1]] = null;
                    this.board[to[0]][to[1]] = piece;
                    if (piece.pieceType === 'p') {
                        piece.hasMoved = true;
                    }
                    this.enemies[this.enemies.findIndex(e => e[0] === from[0] && e[1] === from[1])] = to;
                    if (from === this.mainAttacker) {
                        this.mainAttacker = to;
                    }
                });
            }

            updateAttackingForce() {
                this.attackingForce = [];

                const sortedEnemies = [...this.enemies].sort((a, b) => {
                    const pieceA = this.board[a[0]][a[1]];
                    const pieceB = this.board[b[0]][b[1]];
                    const valueA = this.getPieceValue(pieceA.pieceType);
                    const valueB = this.getPieceValue(pieceB.pieceType);
                    const distA = (a[0] - this.selectedPos[0])**2 + (a[1] - this.selectedPos[1])**2;
                    const distB = (b[0] - this.selectedPos[0])**2 + (b[1] - this.selectedPos[1])**2;
                    return (valueB - valueA) || (distA - distB);
                });

                for (const enemy of sortedEnemies) {
                    const [row, col] = enemy;
                    const piece = this.board[row][col];
                    if (piece && !piece.justSpawned) {
                        this.attackingForce.push(enemy);
                    }
                }

                // Limit the attacking force to a maximum of 4 pieces
                this.attackingForce = this.attackingForce.slice(0, 4);

                if (this.attackingForce.length > 0) {
                    this.mainAttacker = this.attackingForce.reduce((closest, current) => {
                        const closestDist = (closest[0] - this.selectedPos[0])**2 + (closest[1] - this.selectedPos[1])**2;
                        const currentDist = (current[0] - this.selectedPos[0])**2 + (current[1] - this.selectedPos[1])**2;
                        return currentDist < closestDist ? current : closest;
                    });
                } else {
                    this.mainAttacker = null;
                }

                console.log(`Updated attacking force: ${this.attackingForce}`);
                console.log(`Main attacker: ${this.mainAttacker}`);
            }

            getPieceValue(pieceType) {
                const values = {'Q': 9, 'R': 5, 'B': 3, 'N': 3, 'p': 1};
                return values[pieceType] || 0;
            }

            getStrategicMove(piece, currentPos, validMoves, isMainAttacker) {
                if (isMainAttacker) {
                    return this.mainAttackerStrategy(piece.pieceType, currentPos, validMoves);
                }
                return this.supportStrategy(piece.pieceType, currentPos, validMoves);
            }

            mainAttackerStrategy(_pieceType, currentPos, validMoves) {
                const aggressiveMoves = validMoves.filter(move => this.isAggressiveMove(currentPos, move));
                const protectedAggressiveMoves = aggressiveMoves.filter(move => this.isPositionProtected(move, 'b'));

                if (protectedAggressiveMoves.length > 0) {
                    return protectedAggressiveMoves[Math.floor(Math.random() * protectedAggressiveMoves.length)];
                }
                if (aggressiveMoves.length > 0) {
                    return aggressiveMoves[Math.floor(Math.random() * aggressiveMoves.length)];
                }
                return this.closingInStrategy(currentPos, validMoves, this.selectedPos);
            }

            supportStrategy(_pieceType, currentPos, validMoves) {
                const keySquares = this.getKeySquares();
                const controllingMoves = validMoves.filter(move => keySquares.some(ks => ks[0] === move[0] && ks[1] === move[1]));

                if (controllingMoves.length > 0) {
                    return controllingMoves[Math.floor(Math.random() * controllingMoves.length)];
                }
                return this.closingInStrategy(currentPos, validMoves, this.mainAttacker);
            }

            isAggressiveMove(currentPos, newPos) {
                const currentDistance = Math.sqrt((currentPos[0] - this.selectedPos[0])**2 + (currentPos[1] - this.selectedPos[1])**2);
                const newDistance = Math.sqrt((newPos[0] - this.selectedPos[0])**2 + (newPos[1] - this.selectedPos[1])**2);
                return newDistance < currentDistance;
            }

            getKeySquares() {
                const keySquares = new Set();

                this.addSquaresAroundPosition(keySquares, this.selectedPos, 2);

                if (this.mainAttacker) {
                    this.addSquaresAroundPosition(keySquares, this.mainAttacker, 1);
                }

                return Array.from(keySquares);
            }

            addSquaresAroundPosition(keySquares, position, range) {
                const [baseRow, baseCol] = position;
                for (let i = -range; i <= range; i++) {
                    for (let j = -range; j <= range; j++) {
                        const row = baseRow + i;
                        const col = baseCol + j;
                        if (this.isWithinBounds(row, col)) {
                            keySquares.add([row, col]);
                        }
                    }
                }
            }

            isWithinBounds(row, col) {
                return 0 <= row && row < ROWS && 0 <= col && col < COLS;
            }

            closingInStrategy(currentPos, validMoves, target) {
                const dx = target[0] - currentPos[0];
                const dy = target[1] - currentPos[1];

                const preferredMoves = validMoves.filter(move =>
                    (dx > 0 && move[0] > currentPos[0] || dx < 0 && move[0] < currentPos[0]) &&
                    (dy > 0 && move[1] > currentPos[1] || dy < 0 && move[1] < currentPos[1])
                );

                if (preferredMoves.length > 0) {
                    return preferredMoves[Math.floor(Math.random() * preferredMoves.length)];
                }
                return validMoves.reduce((closest, move) => {
                    const closestDist = (closest[0] - target[0])**2 + (closest[1] - target[1])**2;
                    const currentDist = (move[0] - target[0])**2 + (move[1] - target[1])**2;
                    return currentDist < closestDist ? move : closest;
                });
            }

            spawnEnemy() {
                if (this.turnCount < 2) return;

                console.log(`\nAttempting to spawn enemy on turn ${this.turnCount}`);
                
                const spawnLocations = this.getSpawnLocations();
                
                if (spawnLocations.length > 0) {
                    const [row, col] = spawnLocations[Math.floor(Math.random() * spawnLocations.length)];
                    const pieceType = this.chooseEnemyPieceType();

                    const newPiece = new Piece('b', pieceType);
                    newPiece.justSpawned = true;
                    if (pieceType === 'p') {
                        newPiece.direction = row < 4 ? 1 : -1;  // Down if spawned in upper half, up if spawned in lower half
                        newPiece.hasMoved = false;
                    }

                    this.addAnimation('spawn', null, [row, col], newPiece, 500);

                    this.pendingMoves.push(() => {
                        this.board[row][col] = newPiece;
                        this.enemies.push([row, col]);
                        this.lastSpawned = [row, col];
                        console.log(`Spawned ${pieceType} at ${[row, col]}`);
                    });
                } else {
                    console.log('No free squares to spawn');
                }
            }

            getSpawnLocations() {
                let candidateLocations = [];

                switch (this.spawnMode) {
                    case "white border only":
                        candidateLocations = this.getBorderSquares(true);
                        break;
                    case "black border only":
                        candidateLocations = this.getBorderSquares(false);
                        break;
                    case "white and black border":
                        candidateLocations = this.getBorderSquares();
                        break;
                    case "farthest":
                        candidateLocations = this.getAllSquares();
                        break;
                }

                // Filter out occupied squares
                candidateLocations = candidateLocations.filter(([row, col]) => this.board[row][col] === null);

                // Find the furthest square(s) from the player
                const [playerRow, playerCol] = this.selectedPos;
                let maxDistance = 0;
                let furthestLocations = [];

                for (const [row, col] of candidateLocations) {
                    const distance = Math.max(Math.abs(row - playerRow), Math.abs(col - playerCol));
                    if (distance > maxDistance) {
                        maxDistance = distance;
                        furthestLocations = [[row, col]];
                    } else if (distance === maxDistance) {
                        furthestLocations.push([row, col]);
                    }
                }

                return furthestLocations;
            }

            getAllSquares() {
                const allSquares = [];
                for (let i = 0; i < ROWS; i++) {
                    for (let j = 0; j < COLS; j++) {
                        allSquares.push([i, j]);
                    }
                }
                return allSquares;
            }

            drawPawnDirectionIndicator(ctx, row, col, direction) {
                const x = (col + 0.5) * SQUARE_SIZE;
                const y = (row + 0.5) * SQUARE_SIZE;
                const arrowSize = SQUARE_SIZE * 0.2;

                ctx.save();
                ctx.fillStyle = 'rgba(255, 255, 0, 0.7)'; // Yellow with some transparency
                ctx.beginPath();
                if (direction === 1) { // Moving down
                    ctx.moveTo(x, y + arrowSize);
                    ctx.lineTo(x - arrowSize / 2, y);
                    ctx.lineTo(x + arrowSize / 2, y);
                } else { // Moving up
                    ctx.moveTo(x, y - arrowSize);
                    ctx.lineTo(x - arrowSize / 2, y);
                    ctx.lineTo(x + arrowSize / 2, y);
                }
                ctx.closePath();
                ctx.fill();
                ctx.restore();
            }

            getBorderSquares(isWhite = null) {
                const borderSquares = [];
                for (let i = 0; i < ROWS; i++) {
                    for (let j = 0; j < COLS; j++) {
                        if (i === 0 || i === ROWS - 1 || j === 0 || j === COLS - 1) {
                            if (isWhite === null || this.isWhiteSquare(i, j) === isWhite) {
                                borderSquares.push([i, j]);
                            }
                        }
                    }
                }
                return borderSquares;
            }

            getFarthestSquares() {
                const [playerRow, playerCol] = this.selectedPos;
                let maxDistance = 0;
                let farthestSquares = [];

                for (let i = 0; i < ROWS; i++) {
                    for (let j = 0; j < COLS; j++) {
                        const distance = Math.max(Math.abs(i - playerRow), Math.abs(j - playerCol));
                        if (distance > maxDistance) {
                            maxDistance = distance;
                            farthestSquares = [[i, j]];
                        } else if (distance === maxDistance) {
                            farthestSquares.push([i, j]);
                        }
                    }
                }

                return farthestSquares;
            }

            chooseEnemyPieceType() {
                const pieceTypes = ['p', 'N', 'B', 'R', 'Q'];
                const random = Math.random();
                let cumulativeProbability = 0;

                for (const pieceType of pieceTypes) {
                    cumulativeProbability += this.spawnRates[pieceType];
                    if (random <= cumulativeProbability) {
                        return pieceType;
                    }
                }

                return 'p'; // Default to pawn if no piece is selected
            }



            chooseWeighted(items, weights) {
                const totalWeight = weights.reduce((sum, weight) => sum + weight, 0);
                const randomNum = Math.random() * totalWeight;
                let weightSum = 0;

                for (let i = 0; i < items.length; i++) {
                    weightSum += weights[i];
                    if (randomNum <= weightSum) {
                        return items[i];
                    }
                }

                return items[items.length - 1];
            }

            getValidMoves(row, col) {
                const piece = this.board[row][col];
                if (!piece) return [];

                let possibleMoves = piece.getPossibleMoves(row, col, this.board);
                return possibleMoves.filter(([r, c]) => {
                    if (r < 0 || r >= ROWS || c < 0 || c >= COLS) return false;
                    const targetPiece = this.board[r][c];
                    if (targetPiece && targetPiece.color === piece.color) return false;
                    if (['Q', 'R', 'B'].includes(piece.pieceType)) {
                        return this.isPathClear([row, col], [r, c]);
                    }
                    return true;
                });
            }

            getAllValidMoves() {
                let moves = this.getValidMoves(...this.selectedPos);
                
                let safeMoves = moves.filter(move => this.isMoveSafe(this.selectedPos, move, true));
                let unsafeMoves = moves.filter(move => !safeMoves.some(safeMove => safeMove[0] === move[0] && safeMove[1] === move[1]));
                
                // Add potential potion moves
                ['Rook', 'Bishop', 'Knight', 'Queen'].forEach(potionType => {
                    if (this.unlockedPotions.has(potionType + ' Potion')) {
                        const tempPiece = new Piece('w', potionType[0]);
                        const potionMoves = this.getValidMoves(...this.selectedPos, tempPiece);
                        const safePotionMoves = potionMoves.filter(move => this.isMoveSafe(this.selectedPos, move, true));
                        const unsafePotionMoves = potionMoves.filter(move => !safePotionMoves.some(safeMove => safeMove[0] === move[0] && safeMove[1] === move[1]));
                        safeMoves = [...safeMoves, ...safePotionMoves];
                        unsafeMoves = [...unsafeMoves, ...unsafePotionMoves];
                    }
                });

                return { safeMoves, unsafeMoves };
            }

            getRookMoves(row, col) {
                const moves = [];
                for (let i = 0; i < ROWS; i++) {
                    if (i !== row) moves.push([i, col]);
                }
                for (let j = 0; j < COLS; j++) {
                    if (j !== col) moves.push([row, j]);
                }
                return moves;
            }

            getBishopMoves(row, col) {
                const moves = [];
                for (let i = 1; i < ROWS; i++) {
                    if (row + i < ROWS && col + i < COLS) moves.push([row + i, col + i]);
                    if (row + i < ROWS && col - i >= 0) moves.push([row + i, col - i]);
                    if (row - i >= 0 && col + i < COLS) moves.push([row - i, col + i]);
                    if (row - i >= 0 && col - i >= 0) moves.push([row - i, col - i]);
                }
                return moves;
            }

            isPathClear(start, end) {
                const [startRow, startCol] = start;
                const [endRow, endCol] = end;
                const rowStep = Math.sign(endRow - startRow);
                const colStep = Math.sign(endCol - startCol);
                let currentRow = startRow + rowStep;
                let currentCol = startCol + colStep;

                while (currentRow !== endRow || currentCol !== endCol) {
                    if (this.board[currentRow][currentCol] !== null) return false;
                    currentRow += rowStep;
                    currentCol += colStep;
                }
                return true;
            }

            printBoardState() {
                if (this.lastPrintedTurn === this.turnCount) {
                    return; // Skip if already printed this turn
                }
                this.lastPrintedTurn = this.turnCount;

                console.log("\n==================== Current Board State ====================");
                console.log(`Turn: ${this.turnCount}`);
                
                const boardState = [];
                for (let row = 0; row < ROWS; row++) {
                    const rowState = {};
                    for (let col = 0; col < COLS; col++) {
                        const piece = this.board[row][col];
                        if (piece) {
                            rowState[col] = `${piece.color}${piece.pieceType}`;
                        } else {
                            rowState[col] = '  ';
                        }
                    }
                    boardState.push(rowState);
                }

                console.table(boardState);

                console.log("Player Position:", this.selectedPos);
                console.log("Enemies:", this.enemies.map(e => `[${e[0]},${e[1]}]`).join(', '));
                console.log("Ingredients:", this.ingredients.map(i => `[${i.row},${i.col}]`).join(', '));
                console.log("Unlocked Potions:", Array.from(this.unlockedPotions).join(', '));
                console.log("=============================================================\n");
            }

            updatePopUps() {
                const currentTime = Date.now();
                const deltaTime = currentTime - this.lastUpdateTime;
                this.lastUpdateTime = currentTime;

                this.popUpTexts.forEach(text => text.update(deltaTime));
                this.popUpTexts = this.popUpTexts.filter(text => !text.isExpired());
            }

            drawPopUps(ctx) {
                this.popUpTexts.forEach(text => text.draw(ctx));
            }

            addPopUp(text, color = 'green', duration = 3000, priority = 0) {
                this.turnPopUps.push({ text, color, duration, priority });
            }

            processTurnPopUps() {
                // Sort popups by priority (higher number = higher priority)
                this.turnPopUps.sort((a, b) => b.priority - a.priority);
                
                // Add sorted popups to the main queue
                this.popUpQueue.push(...this.turnPopUps);
                
                // Clear turn popups
                this.turnPopUps = [];

                if (!this.isShowingPopUp) {
                    this.showNextPopUp();
                }
            }

            showNextPopUp() {
                if (this.popUpQueue.length === 0) {
                    this.isShowingPopUp = false;
                    return;
                }

                this.isShowingPopUp = true;
                const { text, color, duration } = this.popUpQueue.shift();
                const popup = new PopUpText(text, color, duration);

                setTimeout(() => {
                    popup.remove();
                    this.showNextPopUp();
                }, duration);
            }



        }

        class PopUpText {
            constructor(text, color = 'white') {
                this.text = text;
                this.color = color;
                this.element = this.createElement();
            }

            createElement() {
                const element = document.createElement('div');
                element.className = 'popup';
                element.textContent = this.text;
                element.style.color = this.color;
                
                let container = document.querySelector('.popup-container');
                if (!container) {
                    container = document.createElement('div');
                    container.className = 'popup-container';
                    document.body.appendChild(container);
                }
                
                container.appendChild(element);
                setTimeout(() => this.remove(), 2000);
                return element;
            }

            remove() {
                if (this.element && this.element.parentNode) {
                    this.element.parentNode.removeChild(this.element);
                }
            }
        

            createElement() {
                const element = document.createElement('div');
                element.className = `popup-text popup-text-${this.color}`;
                element.textContent = this.text;
                document.body.appendChild(element);
                return element;
            }

            remove() {
                if (this.element && this.element.parentNode) {
                    this.element.parentNode.removeChild(this.element);
                }
            }

            update(deltaTime) {
                this.lifetime -= deltaTime;
                this.alpha = Math.max(0, this.lifetime / 1000); // Fade out over the last second
            }

            draw(ctx) {
                const centerX = GAME_SIZE / 2;
                const centerY = GAME_SIZE / 2;

                ctx.save();
                ctx.font = `bold ${this.fontSize}px Arial`;
                ctx.fillStyle = `rgba(${this.color[0]}, ${this.color[1]}, ${this.color[2]}, ${this.alpha})`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                // Split text into multiple lines if it's too long
                const maxWidth = GAME_SIZE * 0.8;
                const words = this.text.split(' ');
                let lines = [];
                let currentLine = words[0];

                for (let i = 1; i < words.length; i++) {
                    const testLine = currentLine + ' ' + words[i];
                    const metrics = ctx.measureText(testLine);
                    if (metrics.width > maxWidth) {
                        lines.push(currentLine);
                        currentLine = words[i];
                    } else {
                        currentLine = testLine;
                    }
                }
                lines.push(currentLine);

                // Draw each line
                lines.forEach((line, index) => {
                    const yOffset = (index - (lines.length - 1) / 2) * this.fontSize * 1.2;
                    ctx.fillText(line, centerX, centerY + yOffset);
                });

                ctx.restore();
            }

            isExpired() {
                return this.lifetime <= 0;
            }
        }

        class Animation {
            constructor(type, from, to, piece, duration = 300) {
                this.type = type;
                this.from = from;
                this.to = to;
                this.piece = piece;
                this.duration = duration;
                this.startTime = null;
                piece.isAnimating = true;
            }

            start() {
                this.startTime = performance.now();
            }

            update(currentTime) {
                if (!this.startTime) this.start();
                const elapsed = currentTime - this.startTime;
                const progress = Math.min(elapsed / this.duration, 1);
                if (progress === 1) this.piece.isAnimating = false;
                return progress;
            }

            draw(ctx, progress) {
                if (this.type === 'move') {
                    const currentX = this.from[1] * SQUARE_SIZE + (this.to[1] - this.from[1]) * SQUARE_SIZE * progress;
                    const currentY = this.from[0] * SQUARE_SIZE + (this.to[0] - this.from[0]) * SQUARE_SIZE * progress;
                    this.piece.draw(ctx, currentY / SQUARE_SIZE, currentX / SQUARE_SIZE);
                } else if (this.type === 'spawn') {
                    ctx.globalAlpha = progress;
                    this.piece.draw(ctx, this.to[0], this.to[1]);
                    ctx.globalAlpha = 1;
                }
            }
        }

        function getRowColFromMouse(pos) {
            const [x, y] = pos;
            const row = Math.floor(y / SQUARE_SIZE);
            const col = Math.floor(x / SQUARE_SIZE);
            return [row, col];
        }

        function drawBoard(ctx) {
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, GAME_SIZE, GAME_SIZE);
            for (let row = 0; row < ROWS; row++) {
                for (let col = 0; col < COLS; col++) {
                    ctx.fillStyle = ((row + col) % 2 === 0) ? '#d1dced' : '#171513';
                    ctx.fillRect(col * SQUARE_SIZE, row * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE);
                }
            }
        }

        async function loadImages() {
            const pieces = ['wK', 'wQ', 'wR', 'wB', 'wN', 'wp', 'bK', 'bQ', 'bR', 'bB', 'bN', 'bp'];
            for (const piece of pieces) {
                try {
                    const img = new Image();
                    img.src = `images/${piece}.png`;
                    await new Promise((resolve, reject) => {
                        img.onload = resolve;
                        img.onerror = reject;
                    });
                    IMAGES[piece] = img;
                } catch (e) {
                    console.error(`Could not load image for ${piece}: ${e}`);
                    // Create a placeholder colored rectangle
                    const canvas = document.createElement('canvas');
                    canvas.width = SQUARE_SIZE;
                    canvas.height = SQUARE_SIZE;
                    //const ctx = canvas.getContext('2d');
                    ctx.fillStyle = piece[0] === 'w' ? 'white' : 'black';
                    ctx.fillRect(0, 0, SQUARE_SIZE, SQUARE_SIZE);
                    ctx.font = `${SQUARE_SIZE/2}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(piece[1], SQUARE_SIZE/2, SQUARE_SIZE/2);
                    IMAGES[piece] = canvas;
                }
            }
        }

        function resizeCanvas() {
            const containerWidth = window.innerWidth;
            const containerHeight = window.innerHeight;
            const headerHeight = document.getElementById('header').offsetHeight;
            const footerHeight = document.getElementById('footer').offsetHeight;
            const availableHeight = containerHeight - headerHeight - footerHeight;
            // Use 95% of available space
            GAME_SIZE = Math.min(containerWidth, availableHeight) * 0.95;
            canvas.width = GAME_SIZE;
            canvas.height = GAME_SIZE;
            SQUARE_SIZE = GAME_SIZE / COLS;
            //console.log(`Canvas size: ${GAME_SIZE}x${GAME_SIZE}, SQUARE_SIZE: ${SQUARE_SIZE}`);
        }

        function updateGameInfo(chessBoard) {
            if (!chessBoard) {
                console.warn('Chess board is not initialized');
                return;
            }
            document.getElementById('scoreText').textContent = `Score: ${chessBoard.score}`;
            document.getElementById('pieceText').textContent = `Current Piece: ${chessBoard.playerPiece ? chessBoard.playerPiece.pieceType : 'Unknown'}`;
            document.getElementById('turnText').textContent = `Turns: ${chessBoard.turnCount}`;
            document.getElementById('ingredientText').textContent = `Ingredients Collected: ${chessBoard.ingredientsCollected}`;
            chessBoard.updatePeekButton();
            chessBoard.updatePotionUI();
        }

        function handleBoardClick(event) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (event.clientX - rect.left) * scaleX;
            const y = (event.clientY - rect.top) * scaleY;
            makeMove(x, y);
        }

        function handleBoardTouch(event) {
            event.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const touch = event.touches[0];
            const x = (touch.clientX - rect.left) * scaleX;
            const y = (touch.clientY - rect.top) * scaleY;
            makeMove(x, y);
        }

        function makeMove(x, y) {
            const [row, col] = getRowColFromMouse([x, y]);
            if (gameState.chessBoard) {
                gameState.chessBoard.movePlayer(row, col);
                // The game over check is now handled within the Board class methods
            } else {
                console.error("Chess board isn't initialized");
            }
        }

        function toggleReplay() {
            if (!gameState.finalState || !gameState.previousState) {
                console.log('Cannot replay. States are not available.');
                return;
            }

            try {
                if (gameState.isShowingFinalState) {
                    // Switch to previous state
                    gameState.chessBoard.setState(gameState.previousState);
                    gameState.chessBoard.isGameOver = false;
                    gameState.chessBoard.peekActivated = true; // Keep peek activated
                    document.getElementById('replayButton').textContent = 'Show Capture';
                    document.getElementById('stateIndicator').textContent = 'Currently showing: Previous Turn (All pieces revealed)';
                } else {
                    // Switch to final state
                    gameState.chessBoard.setState(gameState.finalState);
                    gameState.chessBoard.isGameOver = true;
                    gameState.chessBoard.peekActivated = true; // Keep peek activated
                    document.getElementById('replayButton').textContent = 'Show Previous';
                    document.getElementById('stateIndicator').textContent = 'Currently showing: Final Capture (All pieces revealed)';
                }

                gameState.isShowingFinalState = !gameState.isShowingFinalState;

                // Redraw the board
                drawBoard(ctx);
                gameState.chessBoard.draw(ctx);

                updateGameInfo(gameState.chessBoard);
            } catch (error) {
                console.error('Error during replay:', error);
                alert('An error occurred during replay. Please try again or restart the game.');
            }
        }

        function disableGameInputs() {
            // Disable canvas click events
            canvas.removeEventListener('click', handleBoardClick);
            canvas.removeEventListener('touchstart', handleBoardTouch);

            // Disable potion buttons
            const potionButtons = document.querySelectorAll('.potionButton');
            potionButtons.forEach(button => button.disabled = true);

            // Disable piece change buttons (if they exist)
            const pieceButtons = document.querySelectorAll('.pieceButton');
            pieceButtons.forEach(button => button.disabled = true);

            // Disable other buttons
            ['undoButton', 'toggleDotsButton', 'peekButton'].forEach(id => {
                const button = document.getElementById(id);
                if (button) button.disabled = true;
            });
        }

        function enableGameInputs() {
            // Re-enable canvas click events
            canvas.addEventListener('click', handleBoardClick);
            canvas.addEventListener('touchstart', handleBoardTouch);

            // Re-enable potion buttons (they will be enabled/disabled based on availability in updatePotionUI)
            const potionButtons = document.querySelectorAll('.potionButton');
            potionButtons.forEach(button => button.disabled = false);

            // Re-enable piece change buttons (if they exist)
            const pieceButtons = document.querySelectorAll('.pieceButton');
            pieceButtons.forEach(button => button.disabled = false);

            // Re-enable other buttons
            ['undoButton', 'toggleDotsButton', 'peekButton'].forEach(id => {
                const button = document.getElementById(id);
                if (button) button.disabled = false;
            });
        }

        function startGame() {
            gameState.chessBoard = new Board();

            // Add event listeners
            document.getElementById('undoButton').addEventListener('click', () => {
                if (gameState.chessBoard) {
                    gameState.chessBoard.undoMove();
                }
            });

            document.getElementById('toggleDotsButton').addEventListener('click', () => {
                if (gameState.chessBoard) {
                    gameState.chessBoard.toggleDots();
                }
            });

            document.getElementById('peekButton').addEventListener('click', () => {
                if (gameState.chessBoard) {
                    gameState.chessBoard.togglePeek();
                    updateGameInfo(gameState.chessBoard);
                }
            });

            document.getElementById('useRookPotion').addEventListener('click', () => gameState.chessBoard.usePotion('Rook'));
            document.getElementById('useBishopPotion').addEventListener('click', () => gameState.chessBoard.usePotion('Bishop'));
            document.getElementById('useKnightPotion').addEventListener('click', () => gameState.chessBoard.usePotion('Knight'));
            document.getElementById('useQueenPotion').addEventListener('click', () => gameState.chessBoard.usePotion('Queen'));

            canvas.addEventListener('click', handleBoardClick);
            canvas.addEventListener('touchstart', handleBoardTouch);

            // New mouse move event listener
            canvas.addEventListener('mousemove', (event) => {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const x = (event.clientX - rect.left) * scaleX;
                const y = (event.clientY - rect.top) * scaleY;
                if (gameState.chessBoard) {
                    gameState.chessBoard.handleMouseMove(x, y);
                }
            });

            // New touch move event listener
            canvas.addEventListener('touchmove', (event) => {
                event.preventDefault();
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const touch = event.touches[0];
                const x = (touch.clientX - rect.left) * scaleX;
                const y = (touch.clientY - rect.top) * scaleY;
                if (gameState.chessBoard) {
                    gameState.chessBoard.handleMouseMove(x, y);
                }
            });

            // New mouseout event listener
            canvas.addEventListener('mouseout', () => {
                if (gameState.chessBoard) {
                    gameState.chessBoard.hoverPos = null;
                }
            });

            canvas.addEventListener('click', (event) => {
                if (!gameState.chessBoard.isPaused) {
                    handleBoardClick(event);
                }
            });

            // const pieceButtons = document.querySelectorAll('.pieceButton');
            // pieceButtons.forEach(button => {
            //     button.addEventListener('click', () => {
            //         if (gameState.chessBoard) {
            //             const pieceType = button.getAttribute('data-piece');
            //             gameState.chessBoard.changePlayerPiece(pieceType);
            //         }
            //     });
            // });

            gameLoop();
        }

        function showGameStartPopup() {
            const gameStartDiv = document.createElement('div');
            gameStartDiv.id = 'gameStart';
            gameStartDiv.classList.add('game-over'); // We can reuse the game-over class for styling

            gameStartDiv.innerHTML = `
                <h2>Reign check</h2>
                <p class="game-over-subheading">How long can you survive in a kingdom that has lost its way?</p>
                <p class="game-over-subheading"><b>Fight back!</b>, be wary of shadows, and utilize your alchemist skills and maybe you can get out of this alive...</p>
                <br>
                <p>1 enemy spawns per turn (RED), 1 enemy moves per turn (Yellow)</p>
                <p>Enemies can hide in shadow squares, beware of their movements</p>
                <p>Collect ingredients '?' to craft potions.</p>
                <p>Potions transform into more powerful pieces for 1 turn.</p>
                <p>Capture enemy pieces to gain points and their ingredients.</p>
                <p>Survive as long as you can!</p>
                <button id="startGameButton">I accept your challenge</button>
            `;

            document.body.appendChild(gameStartDiv);

            document.getElementById('startGameButton').addEventListener('click', () => {
                document.body.removeChild(gameStartDiv);
                startGame();
            });
        }

        function gameOver(killerPiece, killerLocation) {
            gameState.chessBoard.isGameOver = true;
            
            // Activate peek to reveal all pieces
            gameState.chessBoard.peekActivated = true;
            
            // Redraw the board to show all pieces
            drawBoard(ctx);
            gameState.chessBoard.draw(ctx);
            
            const gameOverDiv = document.createElement('div');
            gameOverDiv.id = 'gameOver';
            gameOverDiv.classList.add('game-over');
            
            const stats = gameState.chessBoard.getGameStats();
            let subheading = getGameOverSubheading(gameState.chessBoard.score, killerPiece, killerLocation);
            
            gameOverDiv.innerHTML = `
                <h2>Game Over</h2>
                <p class="game-over-subheading">${subheading}</p>
                <p>Your score: ${gameState.chessBoard.score}</p>
                <p>Turns survived: ${gameState.chessBoard.turnCount}</p>
                <p>Ingredients collected: ${stats.ingredientsCollected}</p>
                <p>Potions used: ${stats.potionsUsed}</p>
                <p>Emergency turns used: ${stats.emergencyTurnsUsed}</p>
                <p>Pieces captured: ${stats.piecesCaptured}</p>
                <p id="stateIndicator">Currently showing: Final Capture (All pieces revealed)</p>
                <button id="replayButton" onclick="toggleReplay()">Show Previous</button>
                <button id="showMovesButton" onclick="toggleShowMoves()">Show Moves</button>
                <br>
                <button id="playAgainButton" onclick="restartGame()">Play Again</button>
            `;

            document.body.appendChild(gameOverDiv);

            // Enable the buttons
            document.getElementById('replayButton').disabled = false;
            document.getElementById('showMovesButton').disabled = false;
            document.getElementById('playAgainButton').disabled = false;

            // Disable all game inputs
            disableGameInputs();

            // Store the final state and the state before the final move
            gameState.finalState = gameState.chessBoard.getState();
            gameState.previousState = gameState.chessBoard.previousState;

            // Ensure peek is activated in both states
            gameState.finalState.peekActivated = true;
            if (gameState.previousState) {
                gameState.previousState.peekActivated = true;
            }

            // Initialize showMoves flag
            gameState.showingMoves = false;
        }

        function toggleShowMoves() {
            gameState.showingMoves = !gameState.showingMoves;
            const button = document.getElementById('showMovesButton');
            button.textContent = gameState.showingMoves ? 'Hide Moves' : 'Show Moves';

            if (gameState.showingMoves) {
                // If we're showing the final state, switch to the previous state to show moves
                if (gameState.isShowingFinalState && gameState.previousState) {
                    gameState.chessBoard.setState(gameState.previousState);
                }
                gameState.chessBoard.showDots = true;
            } else {
                gameState.chessBoard.showDots = false;
            }

            // Redraw the board
            drawBoard(ctx);
            gameState.chessBoard.draw(ctx);
            gameState.chessBoard.drawEnemyMoves(ctx);

            // If we switched to the previous state, switch back to the final state
            if (gameState.showingMoves && gameState.isShowingFinalState && gameState.finalState) {
                gameState.chessBoard.setState(gameState.finalState);
            }
        }

        function getGameOverSubheading(score, killerPiece, killerLocation) {
            const pieceNames = {
                'p': 'Pawn',
                'R': 'Rook',
                'N': 'Knight',
                'B': 'Bishop',
                'Q': 'Queen',
                'K': 'King'
            };

            const pieceName = pieceNames[killerPiece] || 'Unknown piece';
            const chessCoordinates = killerLocation ? indexToChessCoordinate(killerLocation[0], killerLocation[1]) : 'unknown location';

            if (score >= 50) {
                const phrases = [
                    `You were finally taken down by a ${pieceName} from ${chessCoordinates}.`,
                    `After a valiant effort, a ${pieceName} at ${chessCoordinates} ended your run.`,
                    `Your impressive journey was halted by a ${pieceName} from ${chessCoordinates}.`
                ];
                return phrases[Math.floor(Math.random() * phrases.length)];
            } else if (score >= 25) {
                const phrases = [
                    `A ${pieceName} from ${chessCoordinates} brought your game to an end.`,
                    `Your chess adventure was cut short by a ${pieceName} at ${chessCoordinates}.`,
                    `A strategic move by a ${pieceName} from ${chessCoordinates} sealed your fate.`
                ];
                return phrases[Math.floor(Math.random() * phrases.length)];
            } else if (score >= 10) {
                const phrases = [
                    `You were outmaneuvered by a ${pieceName} from ${chessCoordinates}.`,
                    `A ${pieceName} at ${chessCoordinates} proved to be your undoing.`,
                    `Your chess skills were no match for the ${pieceName} at ${chessCoordinates}.`
                ];
                return phrases[Math.floor(Math.random() * phrases.length)];
            } else {
                const phrases = [
                    `You were swiftly defeated by a ${pieceName} from ${chessCoordinates}.`,
                    `A ${pieceName} at ${chessCoordinates} made quick work of your defenses.`,
                    `Your brief reign was ended by a ${pieceName} from ${chessCoordinates}.`
                ];
                return phrases[Math.floor(Math.random() * phrases.length)];
            }
        }

        function indexToChessCoordinate(row, col) {
            const files = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'];
            const rank = 8 - row;  // Chess boards are numbered from bottom to top
            const file = files[col];
            return `${file}${rank}`;
        }

        function restartGame() {
            const gameOverDiv = document.getElementById('gameOver');
            if (gameOverDiv) {
                document.body.removeChild(gameOverDiv);
            }

            // Reset the game state
            gameState.chessBoard = new Board();
            gameState.finalState = null;
            gameState.previousState = null;
            gameState.isShowingFinalState = true;

            // Reset show moves state
            gameState.showingMoves = false;

            // Clear any lingering effects
            gameState.chessBoard.peekActivated = false;
            gameState.chessBoard.showDots = false;

            // Update the game info and re-enable inputs
            updateGameInfo(gameState.chessBoard);
            enableGameInputs();

            // Ensure the canvas is properly sized
            resizeCanvas();

            // Redraw the board
            drawBoard(ctx);
            gameState.chessBoard.draw(ctx);

            // Restart the game loop if it's not already running
            if (!gameState.isGameLoopRunning) {
                gameState.isGameLoopRunning = true;
                requestAnimationFrame(gameLoop);
            }

            console.log("Game restarted and board redrawn");
        }

        async function main() {
                canvas = document.getElementById('gameCanvas');
                ctx = canvas.getContext('2d');

                await loadImages();
                resizeCanvas();
                window.addEventListener('resize', resizeCanvas);

                // Mouse move event listener (add this outside the gameLoop function)
                canvas.addEventListener('mousemove', (event) => {
                    const rect = canvas.getBoundingClientRect();
                    const scaleX = canvas.width / rect.width;
                    const scaleY = canvas.height / rect.height;
                    const mouseX = (event.clientX - rect.left) * scaleX;
                    const mouseY = (event.clientY - rect.top) * scaleY;
                    gameState.mousePos = [mouseX, mouseY];
                });

                // Show the game start popup
                showGameStartPopup();

                // The rest of the event listeners and game initialization will be moved to startGame()

            }

            function gameLoop() {
                if (!gameState.chessBoard.isPaused) {
                    if (gameState.isGameLoopRunning) {
                        if (canvas.width !== GAME_SIZE || canvas.height !== GAME_SIZE) {
                            resizeCanvas();
                        }
                        drawBoard(ctx);
                        if (gameState.chessBoard) {
                            gameState.chessBoard.draw(ctx);
                            
                            // Process any ongoing animations
                            if (gameState.chessBoard.animations.length > 0) {
                                const currentTime = performance.now();
                                gameState.chessBoard.animations = gameState.chessBoard.animations.filter(animation => {
                                    return animation.update(currentTime) < 1;
                                });

                                // Apply pending moves if all animations are complete
                                if (gameState.chessBoard.animations.length === 0) {
                                    for (const move of gameState.chessBoard.pendingMoves) {
                                        move();
                                    }
                                    gameState.chessBoard.pendingMoves = [];
                                }
                            }

                            updateGameInfo(gameState.chessBoard);
                        }
                    }
                        

                }       
                requestAnimationFrame(gameLoop);
            }

            

            

        // Call main function when the DOM is fully loaded
        document.addEventListener('DOMContentLoaded', main);
    </script>
</body>
</html>